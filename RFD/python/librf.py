# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_librf', [dirname(__file__)])
        except ImportError:
            import _librf
            return _librf
        if fp is not None:
            try:
                _mod = imp.load_module('_librf', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _librf = swig_import_helper()
    del swig_import_helper
else:
    import _librf
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class constraint_set(_object):
    """Proxy of C++ constraint_set class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, constraint_set, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, constraint_set, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(constraint_set self, vector< int > * Cons) -> constraint_set"""
        this = _librf.new_constraint_set(*args)
        try: self.this.append(this)
        except: self.this = this
    def size(self):
        """size(constraint_set self) -> int"""
        return _librf.constraint_set_size(self)

    def to_array(self, *args):
        """to_array(constraint_set self, int * pairs)"""
        return _librf.constraint_set_to_array(self, *args)

    __swig_destroy__ = _librf.delete_constraint_set
    __del__ = lambda self : None;
constraint_set_swigregister = _librf.constraint_set_swigregister
constraint_set_swigregister(constraint_set)

class ClosureUtils(_object):
    """Proxy of C++ ClosureUtils class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClosureUtils, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClosureUtils, name)
    __repr__ = _swig_repr
    def pairwise_closure(*args):
        """pairwise_closure(int const * pairs, int const numpairs) -> topclosure *"""
        return _librf.ClosureUtils_pairwise_closure(*args)

    if _newclass:pairwise_closure = staticmethod(pairwise_closure)
    __swig_getmethods__["pairwise_closure"] = lambda x: pairwise_closure
    def constraints_from_closure(*args):
        """constraints_from_closure(closure const * close) -> constraint_set"""
        return _librf.ClosureUtils_constraints_from_closure(*args)

    if _newclass:constraints_from_closure = staticmethod(constraints_from_closure)
    __swig_getmethods__["constraints_from_closure"] = lambda x: constraints_from_closure
    def swig_pairwise_closure(*args):
        """swig_pairwise_closure(int const * constraints) -> closure *"""
        return _librf.ClosureUtils_swig_pairwise_closure(*args)

    if _newclass:swig_pairwise_closure = staticmethod(swig_pairwise_closure)
    __swig_getmethods__["swig_pairwise_closure"] = lambda x: swig_pairwise_closure
    def __init__(self): 
        """__init__(ClosureUtils self) -> ClosureUtils"""
        this = _librf.new_ClosureUtils()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _librf.delete_ClosureUtils
    __del__ = lambda self : None;
ClosureUtils_swigregister = _librf.ClosureUtils_swigregister
ClosureUtils_swigregister(ClosureUtils)

def ClosureUtils_pairwise_closure(*args):
  """ClosureUtils_pairwise_closure(int const * pairs, int const numpairs) -> topclosure *"""
  return _librf.ClosureUtils_pairwise_closure(*args)

def ClosureUtils_constraints_from_closure(*args):
  """ClosureUtils_constraints_from_closure(closure const * close) -> constraint_set"""
  return _librf.ClosureUtils_constraints_from_closure(*args)

def ClosureUtils_swig_pairwise_closure(*args):
  """ClosureUtils_swig_pairwise_closure(int const * constraints) -> closure *"""
  return _librf.ClosureUtils_swig_pairwise_closure(*args)

class RandomForest(_object):
    """Proxy of C++ RandomForest class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RandomForest, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RandomForest, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(RandomForest self) -> RandomForest
        __init__(RandomForest self, float const * data, int const * labels, int num_trees, int K, int F, int min_size, 
            int splitfun, int threads, bool compute_unique) -> RandomForest
        """
        this = _librf.new_RandomForest(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _librf.delete_RandomForest
    __del__ = lambda self : None;
    def traintree(*args):
        """traintree(Tree * reftotrain, int treenum, mom::Semaphore * sem)"""
        return _librf.RandomForest_traintree(*args)

    if _newclass:traintree = staticmethod(traintree)
    __swig_getmethods__["traintree"] = lambda x: traintree
    def regrset(self, *args):
        """regrset(RandomForest self, float const * data, float * regs)"""
        return _librf.RandomForest_regrset(self, *args)

    def rfdregr(self, *args):
        """rfdregr(RandomForest self, float const * data, float const * data2, float * dists, bool position)"""
        return _librf.RandomForest_rfdregr(self, *args)

    def rfdcode(self, *args):
        """rfdcode(RandomForest self, float const * data, float * codes, bool position)"""
        return _librf.RandomForest_rfdcode(self, *args)

    def variable_importance(self, *args):
        """variable_importance(RandomForest self, float * vars)"""
        return _librf.RandomForest_variable_importance(self, *args)

    def nearest_multi(self, *args):
        """
        nearest_multi(RandomForest self, float const * points, int const num_points, int * neighbors, float * dists, int const num_neighbors, 
            int const num_candidates)
        """
        return _librf.RandomForest_nearest_multi(self, *args)

    def metric_distance(self, *args):
        """
        metric_distance(RandomForest self, float const * p1, float const * p2) -> float
        metric_distance(RandomForest self, float const * p1, int p2) -> float
        """
        return _librf.RandomForest_metric_distance(self, *args)

    def metric_multi(self, *args):
        """metric_multi(RandomForest self, float const * p1, float const * p2, float * out, int const m)"""
        return _librf.RandomForest_metric_multi(self, *args)

    def metric_matrix(self, *args):
        """metric_matrix(RandomForest self, float const * p1, float const * p2, float * out)"""
        return _librf.RandomForest_metric_matrix(self, *args)

    def read(self, *args):
        """
        read(RandomForest self, char const [] filename)
        read(RandomForest self, istream & i)
        """
        return _librf.RandomForest_read(self, *args)

    def write(self, *args):
        """
        write(RandomForest self, char const [] filename)
        write(RandomForest self, ostream & o)
        """
        return _librf.RandomForest_write(self, *args)

    def ntrees(self):
        """ntrees(RandomForest self) -> int"""
        return _librf.RandomForest_ntrees(self)

    def ndims(self):
        """ndims(RandomForest self) -> int"""
        return _librf.RandomForest_ndims(self)

    def nthreads(self):
        """nthreads(RandomForest self) -> int"""
        return _librf.RandomForest_nthreads(self)

    def C(self):
        """C(RandomForest self) -> int"""
        return _librf.RandomForest_C(self)

    def setnthreads(self, *args):
        """setnthreads(RandomForest self, int threads)"""
        return _librf.RandomForest_setnthreads(self, *args)

    def is_super(self):
        """is_super(RandomForest self) -> bool"""
        return _librf.RandomForest_is_super(self)

    def num_inst(self):
        """num_inst(RandomForest self) -> int"""
        return _librf.RandomForest_num_inst(self)

    def votesset(self, *args):
        """
        votesset(RandomForest self, float const * data, signed char * votes)
        votesset(RandomForest self, float const * data, signed char * votes)
        """
        return _librf.RandomForest_votesset(self, *args)

    def nearest(self, *args):
        """
        nearest(RandomForest self, float const * point, int * neighbors, float * dists, int const num_neighbors, int const num_candidates)
        nearest(RandomForest self, float const * points, int * neighbors, float * dists, int candidates)
        """
        return _librf.RandomForest_nearest(self, *args)

    def metric(self, *args):
        """metric(RandomForest self, float const * p1, float const * p2, float * out)"""
        return _librf.RandomForest_metric(self, *args)

RandomForest_swigregister = _librf.RandomForest_swigregister
RandomForest_swigregister(RandomForest)

def RandomForest_cons(*args):
    """
    RandomForest_cons(float const * data, int const * constraints, int num_trees, int K, int F, int min_size, 
        int splitfun, int threads, bool compute_unique, float splitweight, float distweight, 
        float satweight, float certfactor) -> RandomForest
    """
    val = _librf.new_RandomForest_cons(*args)
    return val

def RandomForest_traintree(*args):
  """RandomForest_traintree(Tree * reftotrain, int treenum, mom::Semaphore * sem)"""
  return _librf.RandomForest_traintree(*args)

from numpy import zeros, int32

def constraintsFromClosure(cons):
	"""
	Expands a constraint set by computing its closure and generating the full set of inferable constraints
	
	cons = numconstraints by 3 int32 numpy array containing a must-link or cannot-link point pair on each line
	
	returns: an m by 3 int32 numpy array containing a must-link or cannot-link point pair on each line, where
		m is the number of unique constraints extracted from the computed constraint closure
	"""
	
	if(cons==None or cons.shape[0]==0):
	    return cons
	close = ClosureUtils_swig_pairwise_closure(cons)
	cs = ClosureUtils_constraints_from_closure(close)
	out = zeros((cs.size(), 3), dtype=int32)
	cs.to_array(out)
	del close
	del cs
	return out

# This file is compatible with both classic and new-style classes.


